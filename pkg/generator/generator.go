package generator

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"golang.org/x/tools/go/ast/astutil"
	"io/ioutil"
)

// Generator generates the typed syncmap object.
type Generator struct {
	// flag options.
	pkg   string // package name.
	source string // source file needed to be mutated
	key   string // map key type.
	value string // map value type.
	// mutation state and traversal handlers.
	file   *ast.File
	fset   *token.FileSet

	funcs  map[string]func(*ast.FuncDecl)
	types  map[string]func(*ast.TypeSpec)
	values map[string]func(*ast.ValueSpec)
	names map[string]string
}

type Implementation interface {
	Values() map[string]func(*ast.ValueSpec)
	Types() map[string]func(*ast.TypeSpec)
	Funcs() map[string]func(*ast.FuncDecl)
	Names() map[string]string
}

// NewGenerator returns a new generator for syncmap.
func New(pkg, source, typ string, impl Implementation) (g *Generator, err error) {
	defer Catch(&err)
	g = &Generator{
		fset: token.NewFileSet(),
		pkg: pkg,
		source:source,
	}
	g.funcs = impl.Funcs()
	g.types = impl.Types()
	g.values = impl.Values()
	g.names = impl.Names()
	exp, err := parser.ParseExpr(typ)
	Check(err, "parse expr: %s", typ)
	m, ok := exp.(*ast.MapType)
	Expect(ok, "invalid argument. expected map[T1]T2")
	b := bytes.NewBuffer(nil)
	err = format.Node(b, g.fset, m.Key)
	Check(err, "format map key")
	g.key = b.String()
	b.Reset()
	err = format.Node(b, g.fset, m.Value)
	Check(err, "format map value")
	g.value = b.String()
	return
}

// Mutate mutates the original `sync/map` AST and brings it to the desired state.
// It fails if it encounters an unrecognized node in the AST.
func (g *Generator) Mutate() (err error) {
	defer Catch(&err)
	path := g.source
	b, err := ioutil.ReadFile(path)
	Check(err, "read %q file", path)
	f, err := parser.ParseFile(g.fset, "", b, parser.ParseComments)
	Check(err, "parse %q file", path)
	f.Name.Name = g.pkg
	astutil.AddImport(g.fset, f, "sync")
	for _, d := range f.Decls {
		switch d := d.(type) {
		case *ast.FuncDecl:
			handler, ok := g.funcs[d.Name.Name]
			Expect(ok, "unrecognized function: %s", d.Name.Name)
			handler(d)
			delete(g.funcs, d.Name.Name)
		case *ast.GenDecl:
			switch d := d.Specs[0].(type) {
			case *ast.TypeSpec:
				handler, ok := g.types[d.Name.Name]
				Expect(ok, "unrecognized type: %s", d.Name.Name)
				handler(d)
				delete(g.types, d.Name.Name)
			case *ast.ValueSpec:
				handler, ok := g.values[d.Names[0].Name]
				Expect(ok, "unrecognized value: %s", d.Names[0].Name)
				handler(d)
				Expect(len(d.Names) == 1, "mismatch values length: %d", len(d.Names))
				delete(g.values, d.Names[0].Name)
			}
		default:
			Expect(false, "unrecognized type: %s", d)
		}
	}
	Expect(len(g.funcs) == 0, "function was deleted")
	Expect(len(g.types) == 0, "type was deleted")
	Expect(len(g.values) == 0, "value was deleted")
	Rename(f, g.names)
	g.file = f
	return
}

// Gen dumps the mutated AST to a file in the configured destination.
func (g *Generator) Generate() (out []byte, err error) {
	defer Catch(&err)
	b := bytes.NewBuffer([]byte("// Code generated by go-generate; DO NOT EDIT.\n\n"))
	err = format.Node(b, g.fset, g.file)
	Check(err, "format mutated code")
	return b.Bytes(), err
}

// ReplaceKey replaces all `interface{}` occurrences in the given Node with the key node.
func (g *Generator) ReplaceKey(n ast.Node) { ReplaceIface(n, g.key) }

// ReplaceValue replaces all `interface{}` occurrences in the given Node with the value node.
func (g *Generator) ReplaceValue(n ast.Node) { ReplaceIface(n, g.value) }
