package generator

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"

	"golang.org/x/tools/go/ast/astutil"
)

// Generator generates the typed syncmap object.
type Generator struct {
	// flag options.
	pkg    string // package name.
	source string // source file needed to be mutated

	// mutation state and traversal handlers.
	file *ast.File
	fset *token.FileSet

	impl   Implementation
	funcs  map[string]func(*ast.FuncDecl)
	types  map[string]func(*ast.TypeSpec)
	values map[string]func(*ast.ValueSpec)
}

type Implementation interface {
	Values() map[string]func(*ast.ValueSpec)
	Types() map[string]func(*ast.TypeSpec)
	Funcs() map[string]func(*ast.FuncDecl)
	Mutate() error
}

// NewGenerator returns a new generator.
func New(pkg, source string, impl Implementation) (g *Generator, err error) {
	defer Catch(&err)
	g = &Generator{
		fset:   token.NewFileSet(),
		pkg:    pkg,
		impl:   impl,
		source: source,
	}
	g.funcs = impl.Funcs()
	g.types = impl.Types()
	g.values = impl.Values()

	return
}

// Mutate mutates the original AST and brings it to the desired state.
// It fails if it encounters an unrecognized node in the AST.
func (g *Generator) Mutate() (err error) {
	defer Catch(&err)
	path := g.source
	b, err := ioutil.ReadFile(path)
	Check(err, "read %q file", path)
	f, err := parser.ParseFile(g.fset, "", b, parser.ParseComments)
	Check(err, "parse %q file", path)
	f.Name.Name = g.pkg
	for _, d := range f.Decls {
		switch d := d.(type) {
		case *ast.FuncDecl:
			handler, ok := g.funcs[d.Name.Name]
			Expect(ok, "unrecognized function: %s", d.Name.Name)
			handler(d)
			delete(g.funcs, d.Name.Name)
		case *ast.GenDecl:
			switch d := d.Specs[0].(type) {
			case *ast.TypeSpec:
				handler, ok := g.types[d.Name.Name]
				Expect(ok, "unrecognized type: %s", d.Name.Name)
				handler(d)
				delete(g.types, d.Name.Name)
			case *ast.ValueSpec:
				handler, ok := g.values[d.Names[0].Name]
				Expect(ok, "unrecognized value: %s", d.Names[0].Name)
				handler(d)
				Expect(len(d.Names) == 1, "mismatch values length: %d", len(d.Names))
				delete(g.values, d.Names[0].Name)
			}
		default:
			Expect(false, "unrecognized type: %s", d)
		}
	}
	Expect(len(g.funcs) == 0, "function was deleted")
	Expect(len(g.types) == 0, "type was deleted")
	Expect(len(g.values) == 0, "value was deleted")
	g.file = f
	return g.impl.Mutate()
}

// Gen dumps the mutated AST to a file in the configured destination.
func (g *Generator) Generate() (out []byte, err error) {
	defer Catch(&err)
	b := bytes.NewBuffer([]byte("// Code generated by go-generate; DO NOT EDIT.\n\n"))
	err = format.Node(b, g.fset, g.file)
	Check(err, "format mutated code")
	return b.Bytes(), err
}

func (g *Generator) FormatNode(dst io.Writer, node interface{}) error {
	return format.Node(dst, g.fset, node)
}

func (g *Generator) Rename(names map[string]string) {
	Rename(g.file, names)
}

func (g *Generator) AddImport(path string) {
	astutil.AddImport(g.fset, g.file, path)
}
